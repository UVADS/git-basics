{"0": {
    "doc": "Setup & Install",
    "title": "Set Up &amp; Install Git",
    "content": "Contents . | Set Up \\&amp; Install Git . | Contents | Command-Line Git | Mac | Windows | . | Linux . | Authentication Options | First-time Configuration | . | . Setting up git and authenticating yourself to GitHub is an important first step in managing and tracking your code and various projects. Follow the steps for your platform below . ",
    "url": "/#set-up--install-git",
    
    "relUrl": "/#set-up--install-git"
  },"1": {
    "doc": "Setup & Install",
    "title": "Command-Line Git",
    "content": "Data scientists and software developers who write code regularly greatly tend to use the terminal/command-line to interact with git. This primer assumes this and does not address various GUI tools for working with git and GitHub. ",
    "url": "/#command-line-git",
    
    "relUrl": "/#command-line-git"
  },"2": {
    "doc": "Setup & Install",
    "title": "Mac",
    "content": "Here’s a walkthrough for Mac users on how to set up git-bash, SSH keys, and GitHub. | Install Git using the instructions at the following link. A git GUI version is optional, but the command line version is required for this course: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git&nbsp; | Check that git is installed in your environment by issuing the git command. | Sign into GitHub by following the instructions for SSH key authentication. (Note that username/password authentication will NOT work using the command line.) The ssh-keygen tool is available to MacOS, Linux, and git-bash (Windows) users. https://docs.github.com/en/get-started/quickstart/set-up-git&nbsp; | See the screencast above for a walkthrough. | . ",
    "url": "/#mac",
    
    "relUrl": "/#mac"
  },"3": {
    "doc": "Setup & Install",
    "title": "Windows",
    "content": "Here’s a walkthrough for Windows users on how to set up git-bash, SSH keys, and GitHub. Using ssh-keygen.exe in git-bash creates a keypair successfully, but (apparently) permissions are incorrect and the normal chmod 700 keyname on the private key does not work. This means that git cannot authenticate to GitHub. To resolve this: . | Use the ssh-keygen.exe command in git-bash to create a new keypair. Use all the default settings; you do not need to set a password for your key. | In Windows Explorer, open your .ssh directory and right-click your id_rsa private key. (It may have more numbers and letters added to the name - that's okay.) An easy way to open Windows Explorer in your current directory is: explorer . | Select Properties, then the Security tab and click Edit... | Check the Deny box next to \"Full Control\" for all groups EXCEPT Administrators. In my test I only needed to \"Deny\" full control to the SYSTEM group. | If you have not already, cat out and copy the contents of your id_rsaXXXX.pub public key to your clipboard. Then visit https://github.com/settings/keys and add a New SSH Key. You can name it something convenient and then paste the public key into the \"Key\" field and save. | Retry your git commands. You will know it works correctly when you can modify a file, git add it, git commit it, and then git push your changes back to GitHub. | See the screencast above for a walkthrough. | . ",
    "url": "/#windows",
    
    "relUrl": "/#windows"
  },"4": {
    "doc": "Setup & Install",
    "title": "Linux",
    "content": "Install git in a Linux distro with the built-in package manager: . Ubuntu: . apt update &amp;&amp; apt install git . CentOS/RHEL: . yum install git . Alpine/APK: . apk add git . Then set up your authentication method (SSH keys or PAT) and configure as instructed below. ",
    "url": "/#linux",
    
    "relUrl": "/#linux"
  },"5": {
    "doc": "Setup & Install",
    "title": "Authentication Options",
    "content": "GitHub offers two ways to authenticate your local workstation with GitHub. Usernames and passwords are no longer an option, as they present security risks. Instead use one of these: . | SSH Keys - the above walkthroughs used SSH keypairs to authenticate your computer to GitHub. These allow your pushes and puls, etc. to authenticate seamlessly to GitHub as a full owner of the repository. | Personal Access Tokens (PATs) - PATs are long, randomized tokens that can be scoped with specific levels of permissions. More on how to authenticate using PATs can be found here. | . ",
    "url": "/#authentication-options",
    
    "relUrl": "/#authentication-options"
  },"6": {
    "doc": "Setup & Install",
    "title": "First-time Configuration",
    "content": "Confirm your installation is working by issuing the git command from within your terminal. You should see a number of subcommands avaialable to you. The first time you use git you will encounter a couple of setup issues: . | The first time you clone a repository from GitHub using a new ssh key you will get a “key fingerprint” approval request. You can safely say “Yes” to this request, which you will only be asked once. | The first time you try to commit code on your laptop using git you will be asked to configure two settings - your name and email. This is simply to identify you in the log of commits and changes. Here are the two settings; replace the values in quotes with your own info: . git config –global user.name “Your Name” git config –global user.email “mst3k@virginia.edu . | . ",
    "url": "/#first-time-configuration",
    
    "relUrl": "/#first-time-configuration"
  },"7": {
    "doc": "Setup & Install",
    "title": "Setup & Install",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"8": {
    "doc": "Repositories",
    "title": "Creating and Managing Git Repositories",
    "content": "Creating a new repository is often confusing to new users of Git and GitHub. Here is a simple explanation of the two options, with complete instructions on how to work with each. The git command displays these options within the --help documentation: . start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing one . ",
    "url": "/#creating-and-managing-git-repositories",
    
    "relUrl": "/#creating-and-managing-git-repositories"
  },"9": {
    "doc": "Repositories",
    "title": "Clone",
    "content": "git clone is the simplest way to begin working with a repository you want connected to GitHub. The clone operation clones an entire remote repository to your local workstation. Assuming you are authenticating to GitHub using SSH keys, here are the steps to cloning: . | Within GitHub find the existing repository you want to clone. | From the repository page, find the blue “Code” button, and select the SSH tab within the dropdown. If you are using a PAT for authentication, use the HTTPS address. | Copy the address, which will look something like git@github.com:UVADS/git-basics.git (SSH) or https://github.com/UVADS/git-basics.git (HTTPS). | In the command-line on your local computer, clone the repo: | . git clone git@github.com:UVADS/git-basics.git . | This will create a new subdirectory with the name of the repository. You can change the name of the directory if you like. | If there are multiple branches in the GitHub repository and you want to clone them all, use these commands: | . git clone git@github.com:UVADS/git-basics.git cd &lt;repository-name&gt; git fetch --all for branch in `git branch -r | grep -v HEAD`; do git checkout -b $branch $branch done . | Note that if you create a new, empty repository within GitHub, it is helpful to tick the box to include a README.md file by default. This ensures that a default branch (named main) will be created for you. | . ",
    "url": "/#clone",
    
    "relUrl": "/#clone"
  },"10": {
    "doc": "Repositories",
    "title": "Init",
    "content": "Git repositories can also be created locally and connected with GitHub after creation. (In fact, there are some cases where a local git repository is used for source control but never connected to an external hub.) . To initialize a local git repository and then connect it with GitHub: . | Create a directory for your new project and cd into it. | Issue the git init command to initialize the repository. | Then add a file and commit it | Create a default branch. | . mkdir project1 echo \"# foo\" &gt;&gt; README.md git init git add README.md git commit -m \"first commit\" git branch -M main . | Next, create an empty repository in GitHub. Do not add a README.md file in that process (leave that unchecked). You will see prompts for how to: . | Create a new repository from the command line | Push an existing repository from the command line (the path followed below) | Import code from another repository | . | Copy the SSH URL to your new repository, which will look something like git@github.com:&lt;account&gt;/&lt;repo&gt;.git | Finally, add the remote origin and push your repo using that URL: | . git remote add origin git@github.com:&lt;account&gt;/&lt;repo&gt;.git git push -u origin main . ",
    "url": "/#init",
    
    "relUrl": "/#init"
  },"11": {
    "doc": "Repositories",
    "title": "Delete",
    "content": "To delete a repository you have both in GitHub and on your local computer, do the following: . | Locally, cd ../ to the parent directory above your project directory, and rm -Rf &lt;project-name&gt; to delete the entire folder. You can also use the MacOS Finder or Windows Explorer to select and delete this folder. | In GitHub, within the repository page itself, click the “Settings” tab, and scroll to the bottom. There you will find a “Delete this repository” button. | . ",
    "url": "/#delete",
    
    "relUrl": "/#delete"
  },"12": {
    "doc": "Repositories",
    "title": "Repositories",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"13": {
    "doc": "Git Basics",
    "title": "Git Basics",
    "content": "This page covers the most essential commands when tracking your code using git and GitHub. | git diff | git status | git add | git commit | git push / git pull | git fetch | git log | . ",
    "url": "/",
    
    "relUrl": "/"
  },"14": {
    "doc": "Git Basics",
    "title": "Diff",
    "content": "Git was designed to track changes made to files and their location within a project. git diff is one of the best ways to see how things have actually changed. git diff is a function that takes two input data sets and outputs the changes between them. For example, imagine that you have cleaned up your code a bit, added some new functionality, and inserted more comments inline. But you step away from your desk (or go to sleep or it’s suddenly the weekend) and you need a reminder of what changes have been made to file before you add and commit it? git diff can tell you. A command like this: . git diff filename.py . will show you a detailed inventory of inserted lines (which start with + and are highlighted in blue), deleted lines (which start with - and are highlighted in red) for the entire file. Or if you need to compare the structure of two directories: . git diff dir1 dir2 . Or if you need to compare the changes between two commits: . git diff 6a63 d726 . Or if you need to compare the last commit with the current state (before commits): . git diff a0ea0 . ",
    "url": "/#diff",
    
    "relUrl": "/#diff"
  },"15": {
    "doc": "Git Basics",
    "title": "Status",
    "content": "Running the git status command at any point will tell you what untracked files are in your project directory, or whether you have added changes that need committing, or whether you need to push. For example, the command below shows that a file has been modified but not yet staged for commit: . $ git status On branch main Your branch is up to date with 'origin/main'. Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: 02-git-basics.md no changes added to commit (use \"git add\" and/or \"git commit -a\") . ",
    "url": "/#status",
    
    "relUrl": "/#status"
  },"16": {
    "doc": "Git Basics",
    "title": "Add",
    "content": "The git add command stages your file(s) to be committed. Instead of thinking of “add” as simply adding new files or changes, think of “add” as adding your changes (new files, edited files, deleted files) to git for tracking. You can specify individual files to be staged for commit: . git add README.md git add my_script.py git add one_script.py config.json requirements.txt . Or you can add everything recursively within the current directory: . git add . Extending the example from above, here is the output from git add .: . $ git add . On branch main Your branch is up to date with 'origin/main'. Changes to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) modified: 02-git-basics.md . ",
    "url": "/#add",
    
    "relUrl": "/#add"
  },"17": {
    "doc": "Git Basics",
    "title": "Commit",
    "content": "The most important action in git is the commit. Commits are permanent, irrevocable transactions that snapshot an entire codebase at a specific moment in time. Remember that the idea of source control is that users can always see the history of all changes to any file within a project, over time. Even users who are new to an existing project can look back into the entire history of commits for a repository. To commit your staged (added) changes, use the git commit command with the -m \"Message...\" flag. Every commit requires a meaningful, plainspoken message describing the commit. git commit -m \"Added new numpy parameter for verbose logging\" . How often should I commit my changes? . As a general rule, commit every time you make an important change - whether that is an addition, modification, or deletion. If you are cleaning up syntax or comments across several files, that could be folded into a single commit. But the addition of a new method or class probably counts as a big enough change to be its own commit. The point is to avoid a single, end-of-the-day commit with 50 unrelated changes. If your commit represents changes made in one file (for example) it is possible to check out a previous version of that file in case you would like to roll back. More about that is in the advanced topics page. Writing good commit messages . The practice of writing quality commit messages is important even for the solo developer. How else can you or a teammate easily pinpoint important changes to a file or entire project? It is important to remember not to err on the side of either (a) overly-brief or repetitive comments, or (b) overly-long narrative commentary that will never be read. Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier. As a general rule, your messages should start with a single line that’s no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation. The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior — this is a good guideline to follow. Write your commit message in the imperative: “Fix bug” and not “Fixed bug” or “Fixes bug.” git-scm.com . ",
    "url": "/#commit",
    
    "relUrl": "/#commit"
  },"18": {
    "doc": "Git Basics",
    "title": "Push / Pull",
    "content": "The actions above have all happened on the local workstation, without really interacting with a remote origin such as GitHub. Pushing and Pulling are the steps to synchronize your local changes with the remote origin. git push . To push your local changes “up” to GitHub issue this command: . git push origin main . The use of origin in this command is a reference to a remote git endpoint (i.e. a hosted service such as GitHub, Bitbucket, etc.) and main is the branch you want to push. Note that origin can actually be renamed, though it’s become the common moniker for any hosted git service. git pull . To pull the most recent version of the repository from GitHub to your local computer, use the same syntax with the pull command: . git pull origin main . Where origin is a reference to the remote endpoint and main is the name of the branch you want to synchronize. How often should I push or pull? . For solo developers who are not working in a team/collaboration, one or two pushes per day should be fine. While GitHub is not a backup service per se, it is always wise to have an external copy of your important work offsite. Hard drives die, and data can get corrupted. For collaboration settings, a good rule of thumb for how frequently to git push is to push every time an important change to the code has been made. And you should git pull at the start of each day of work, and before you begin working on a new or file you have not touched earlier in the day. Ultimately, good team communication matters the most in this environment. Why doesn’t git synchronize automatically like Dropbox? . Since changes to code happen over time and require effort to get to a working state, the git model depends upon developers having their own sense for when code is ready to be committed and added to source control. Put another way, you don’t want half-completed code shipping into the rest of your project. ",
    "url": "/#push--pull",
    
    "relUrl": "/#push--pull"
  },"19": {
    "doc": "Git Basics",
    "title": "Fetch",
    "content": "The git fetch command downloads the latest changes from a remote repository, but it doesn’t merge those changes into your local working directory. This means that you can see what changes have been made to the remote repository without having to merge them into your own work. Fetch is a relatively “harmless” command since it does not modify or delete anything. You can never fetch too often, and the advantage is that it lets you see all remote changes before you commit or merge. How is fetch different from pull? Pulling updates the HEAD of your repository with the changes from the remote repository. So it both pulls down new data/changes but also integrates them with your copy of the repository. What does HEAD mean? HEAD is the name for the current version of the repository, the most recent commit. Notice in the section below, the top-most (i.e. most recent) commit will also be aliased as HEAD. ",
    "url": "/#fetch",
    
    "relUrl": "/#fetch"
  },"20": {
    "doc": "Git Basics",
    "title": "Log",
    "content": "Since git was built to track changes, returning a log of all commits is simple. The default output is verbose and each entry takes several lines: . $ git log commit 6a6357bd9f27663e093ef8b08ed8a1cff6d3685d (HEAD -&gt; main, origin/main, origin/HEAD) Author: Data Student &lt;mst3k@virginia.edu&gt; Date: Wed Feb 28 10:01:24 2024 -0500 Extending the advanced page commit 1c552497f2b80100a0256d2b9bfd36895acca260 Author: Data Student &lt;mst3k@virginia.edu&gt; Date: Tue Feb 27 10:23:34 2024 -0500 Typos abound. Adding second new section. commit 7c271f203df3a9eaab9e2cb6081a4ebda029dfdb Author: Data Student &lt;mst3k@virginia.edu&gt; Date: Tue Feb 27 10:22:13 2024 -0500 Clearer sections in the TOC. Notice that at least four data points are returned for each commit: . | The commit SHA or hash identifier | The commit author and email | The commit date and time | The commit message | . TIP! When referencing other commits you do not need to use the entire hash. Usually the first 4-5 characters are enough, so long as they can be differentiated from any other commits. Notice in the log output below even git itself truncates commit hashes to six characters. The git log can be displayed and manipulated. One useful flag is --online: . $ git log --oneline 6a6357b (HEAD -&gt; main, origin/main, origin/HEAD) Extending the advanced page 1c55249 Typos abound. Adding second new section. 7c271f2 Clearer sectioning in the TOC. 9200074 Tracking - more content and adding 4-5-6 pages 8c0e746 Update 03-forks-branches.md c98492b Width of image dd1ea8e Update 03-forks-branches.md b835f2f Adding image and upstream dc97b96 TOC on page 3 . Even more informative, you can log with a graph output, showing commits across all branches: . $ git log --oneline --graph --decorate --all * 9bccb364 (origin/staging) Updated ANSYS docs and scripts | * 66027815 (HEAD -&gt; main, origin/main, origin/HEAD) Merge pull request #506 from uvarc/staging |\\ |/ |/| * | 0832e6ee timestamp message * | ad6834d7 lammps slurm * | 1f8beb43 lammps cpu and gpu * | 6c7137d3 Changed Gurobi page to reflect latest version | * cfaf53cc Merge pull request #505 from uvarc/staging |\\ |/ |/| * | 9663a4be Pushing changes to people | * 60d037e2 Merge pull request #504 from uvarc/staging |\\ |/ |/| * | 79c0c50e status page update and timestamps . ",
    "url": "/#log",
    
    "relUrl": "/#log"
  },"21": {
    "doc": "Forks & Branches",
    "title": "Branches Forks &amp; Merges",
    "content": "Git enables software developers to copy an existing codebase and work with the copy alongside the original, without one interfering with the other. | The easiest way to copy your entire project code and work with it is called a “Branch”. | The method for copying someone else’s project in order to work with is called a “Fork”. | Bringing your changes back into either your project or someone else’s is called a “Merge”. This function is called a “Pull Request” in GitHub. | . ",
    "url": "/#branches-forks--merges",
    
    "relUrl": "/#branches-forks--merges"
  },"22": {
    "doc": "Forks & Branches",
    "title": "Branches",
    "content": "The default branch of most repositories is called main. Many developers do their everyday work adding and committing to the main branch. But what if you would like to experiment with a new library, or test out new functionality without disrupting the functionality of the original code? This is what a branch is for. A new branch is a complete copy of your code that can have an independent life from the branch it was copied from. To create a new branch (based on a copy of the branch you are currently using) . git branch development . To work with the new branch: . git checkout development . To list all your branches, and indicate which you are currently on (denoted by the *) . $ git branch dev * main . Branches generally end up in one of two possible states: . | The idea / experiment / feature / test that motivated creating the branch in the first place is abandoned and the branch can be deleted. Perhaps the test was unsatisfactory in some way, or impossible to deliver, or otherwise deemed unsuccessful. See how to delete a branch below. | The new functionality of the branch is considered successful, and you want to fold the new code into the original branch. See merges &amp; pull requests below. | . Deleting a branch . To delete a branch: . git branch -d &lt;branch-name&gt; . ",
    "url": "/#branches",
    
    "relUrl": "/#branches"
  },"23": {
    "doc": "Forks & Branches",
    "title": "Forks",
    "content": ". A fork is a copy of someone else’s repository. This is usually because you do not have access to push changes to the repository, or because the organization that controls it requires all changes come through forks and pull requests. When you fork a repository, a complete copy is made in your own account (or Organization) in GitHub. This gives you complete control to clone and work with the code freely. You own the forked copy, so you can make additions, new functionality, and commit+push to your own fork. To create and work with a fork of a repository: . | Go to the project’s page in GitHub that you want to fork. | In the upper-right corner of the page, select the “Fork” button. | You will be asked where you want the fork to exist, and if you want to rename it. | Once copied, you can clone the repo to your local computer. | Make changes, then git add, git commit and git push to your fork. | . ",
    "url": "/#forks",
    
    "relUrl": "/#forks"
  },"24": {
    "doc": "Forks & Branches",
    "title": "Upstream",
    "content": "Repotories that are linked with GitHub already have a remote configuration generally called “origin”. This is a reference to the external hosted version of a repository, i.e. the destination when you git push or the source when you git pull. To see your remote settings for a specific repository, use the verbose output of the git remote command: . $ git remote -v origin git@github.com:UVADS/git-basics.git (fetch) origin git@github.com:UVADS/git-basics.git (push) . In this example, origin is configured for both pulling and pushing. ",
    "url": "/#upstream",
    
    "relUrl": "/#upstream"
  },"25": {
    "doc": "Forks & Branches",
    "title": "Merges / Pull Requests",
    "content": " ",
    "url": "/#merges--pull-requests",
    
    "relUrl": "/#merges--pull-requests"
  },"26": {
    "doc": "Forks & Branches",
    "title": "Forks & Branches",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"27": {
    "doc": "GitHub Issues",
    "title": "GitHub Issues",
    "content": "GitHub Issues is a robust and collaborative issue tracking system that helps teams manage and prioritize tasks, bugs, and feature requests within a GitHub repository. Users can create issues to report problems, suggest enhancements, or outline new features. Each issue acts as a centralized hub for discussions, allowing team members to comment, share insights, and collaborate on problem-solving. Additionally, issues can be assigned to specific team members, labeled for categorization, and linked to pull requests, fostering a seamless integration with the overall development workflow. GitHub Issues provides a structured and transparent way for teams to organize their work, enabling efficient project management. It offers features such as customizable labels, milestones, and project boards to help teams track progress, set priorities, and ensure that all relevant stakeholders are informed about the status and resolution of each issue. This collaborative and integrated approach enhances communication and facilitates a smooth development process by keeping everyone aligned on the project’s goals and tasks. ",
    "url": "/",
    
    "relUrl": "/"
  },"28": {
    "doc": "Advanced Git",
    "title": "Advanced git",
    "content": "Some deeper features you may find useful: . | Advanced git . | Git Stash | Signing commits | Resets and reverting | Rebase | Cherry-pick | Rename origin | Bonus - So You Think You Know Git | . | . ",
    "url": "/#advanced-git",
    
    "relUrl": "/#advanced-git"
  },"29": {
    "doc": "Advanced Git",
    "title": "Git Stash",
    "content": "git stash is a useful command for setting changes aside while you want to perform another git operation, such as a add, push, pull, etc. stash allows you to save your in-progress changes, whether they are staged or unstaged, and puts them aside while reverting your working directory back to HEAD. Git stores stashes in a list that can be reviewed and applied later, if you want to bring those changed files back in. To see all available stashes: . $ git stash list stash@{0}: WIP on main: 26393a3 Another commit stash@{1}: WIP on main: 4d931c4 Testing rebase . If you have only one stash listed, or you want to use the most recent stash (with index 0), you can pull those files/changes back into your branch with . $ git stash pop . If you have more than one stash listed and want to specify which you want to re-incorporate, you need to apply the stash by index (0, 1, 2, …) . $ git stash pop &lt;INDEX&gt; . There are other powerful stash options, such as creating a new branch based on the stash. ",
    "url": "/#git-stash",
    
    "relUrl": "/#git-stash"
  },"30": {
    "doc": "Advanced Git",
    "title": "Signing commits",
    "content": "Why would I sign a commit? . When working in a team of developers (especially large teams), or when developing code around highly sensitive data or processes, verifying the identity of each collaborator is important. Signing a commit proves authorship, increases trust, assures compliance, and generally boosts confidence in the origin of the code. You can sign your commits using a gpg or ssh keypair, or a S/MIME signature. GitHub refers to this as signature verification. Learn more about how to set up sigature verification. Once set up, you can sign any commit, or set a repo/global configuration to always sign your commits. git commit -S -m \"my commit message\" . Developers can also sign pushes in the same way as commits. ",
    "url": "/#signing-commits",
    
    "relUrl": "/#signing-commits"
  },"31": {
    "doc": "Advanced Git",
    "title": "Resets and reverting",
    "content": "Sometimes, despite your best efforts, something is committed into your repository that has gone horribly wrong. Perhaps many files are affected, or the stability of your application is in jeopardy. You need to revert your changes and go back one or more versions in git. Reset - rewinds your history (files and commits) back to the previous commit. # If you are pulling, rebasing or your new code is a mess, and you want to return to the last committed point: # Note that this does not delete newly created files # git clean -f -d will remove newly created files and directories (BEWARE!) git reset --hard # reset to the last commit # HEAD is the current commit, HEAD^ is the last commit # HEAD~2 is the 3rd, HEAD~3 is the 4th and so on... git reset --hard HEAD^ # reset to a particular commit git reset --hard be47384a . Revert - rewinds your files ack to the previous commits by adding a new commit to show this. # Revert the commit 0766c053 # Note that commit may not necessary be the last commit, it can be ANY commit git revert 0766c053 # Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes. git revert HEAD~3 # Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index. git revert -n main~5..main~2 . If you have already pushed your changes, you should use revert since it explains the changes in its history. ",
    "url": "/#resets-and-reverting",
    
    "relUrl": "/#resets-and-reverting"
  },"32": {
    "doc": "Advanced Git",
    "title": "Rebase",
    "content": "From GitHub: . The git rebase command allows you to easily change a series of commits, modifying the history of your repository. You can reorder, edit, or squash commits together. You might rebase to edit previous commit messages, combine commits, and delete/revert unnecessary commits. Read more about methods and approaches to rebasing. Please note that it is considered bad practice to rebase commits that have already been pushed to a repository. This could create considerable problems for other collaborators. ",
    "url": "/#rebase",
    
    "relUrl": "/#rebase"
  },"33": {
    "doc": "Advanced Git",
    "title": "Cherry-pick",
    "content": "Cherry picking is choosing a commit from one branch and applying it to another. Similar to merging and rebasing, cherry picking can be done at the individual file level (or at whatever level of changes you want) instead of an entire branch at a time. Take the example below. A developer has been working on the main branch, while a second developer began a new nav branch. The second developer fixed a bug in the main branch before moving on to other work, and the first developer would like to apply ONLY that bug fix to the main branch. This is an ideal case for using git cherry-pick. When cherry picking you use the hash of any individual commit, available from git log in the branch you want to pick from. In this case, if you want to cherry-pick from the nav branch: . git log nav --oneline . This will display the log of commits for the nav branch, including the hashes of each commit: . e8a582f (nav) added logo to footer f3b9124 Added nav component skeleton 4214d55 Bugfix in config 3359d42 Added app config and README 8196bd8 Initial commit . The commit 4214d55 from nav is the one we want to cherry-pick over into the main branch. This requires only one task, which in itself will be a new commit to main. This must be done while in the main branch itself: . git cherry-pick 4214d55 . cherry-pick also allows you to pull in more than one commit at a time, if that is useful. The syntax would be: . git cherry-pick 4214d55 e8a582f . Git will then digest these commits into the main branch, in the order in which the command was made. Each of these will then become a new commit in the branch (i.e. two commits in this example). If there was a conflict when trying to absorb those cherry-picked changes, you will have to sort out the merge conflict. ",
    "url": "/#cherry-pick",
    
    "relUrl": "/#cherry-pick"
  },"34": {
    "doc": "Advanced Git",
    "title": "Rename origin",
    "content": "When working with remote repository connections, the label origin is typically used for the primary remote host, i.e. GitHub, BitBucket, etc. This is used freqeuently with pushes and pulls to connect the local branch to the appropriate destination or source. $ git push origin main $ git pull origin main . We also use a remote label like upstream when working with forked repositories and need to fetch changes from upstream. However, these names can be changed at any point. To see your current remotes, use: . $ git remote -v origin git@github.com:mst3k/some-repo.git (fetch) origin git@github.com:mst3k/some-repo.git (push) upstream https://github.com/uvads/some-repo.git (fetch) upstream https://github.com/uvads/some-repo.git (push) . Use the built-in command to rename any origin: . $ git remote rename origin destination $ git remote -v destination git@github.com:mst3k/some-repo.git (fetch) destination git@github.com:mst3k/some-repo.git (push) . ",
    "url": "/#rename-origin",
    
    "relUrl": "/#rename-origin"
  },"35": {
    "doc": "Advanced Git",
    "title": "Bonus - So You Think You Know Git",
    "content": "In this video Scott Chacon, one of the co-founders and original developers of GitHub, talks about buried and advanced features in Git and GitHub. Topics include: . | Advanced config options | Signing repo commits and pushes using ssh | Large/Monorepo options | etc. | . ",
    "url": "/#bonus---so-you-think-you-know-git",
    
    "relUrl": "/#bonus---so-you-think-you-know-git"
  },"36": {
    "doc": "Advanced Git",
    "title": "Advanced Git",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"37": {
    "doc": "GitHub Actions",
    "title": "GitHub Actions",
    "content": "GitHub Actions is a continuous integration and continuous delivery (CI/CD) service provided by GitHub. It allows developers to automate various tasks and workflows within their repositories. With GitHub Actions, you can define custom workflows using YAML files that specify the sequence of steps to be executed when certain events occur, such as code pushes, pull requests, or releases. These workflows can include tasks like: . | building code | testing code / unit tests | building containers | deploying applications | notifying team members about failures/errors | triggering remote integrations / APIs | . GitHub Actions helps streamline the development process by automating repetitive tasks, improving collaboration, and ensuring consistent and reliable code deployments. GitHub Actions is highly customizable and integrates seamlessly with other GitHub features and third-party tools. It provides a wide range of pre-built actions and workflows in the GitHub Marketplace, making it easy for developers to adopt and extend existing configurations. Learn More about GitHub Actions . ",
    "url": "/",
    
    "relUrl": "/"
  },"38": {
    "doc": "GitHub Actions",
    "title": "Credentials &amp; Secrets",
    "content": "GitHub Actions often require credentials in order to do some of their work. Consider, for example, a container that is built by an Action that needs to be pushed to Docker Hub. This push requires credentials in order to authenticate to Docker Hub. For this reason, GitHub provides a secret management store where credentials, keys, and other confidential information can be kept within a GitHub repository, account, or organization for use by Actions but not visible to other users. To access Secrets for a repository: . | Go to the main page of the repository | Select “Settings” | On the lefthand navigation find “Secrets and Variables” | Select “Actions” | Create a new repository or organization secret. Each consists of a key-value pair similar to an env variable. | . ",
    "url": "/#credentials--secrets",
    
    "relUrl": "/#credentials--secrets"
  },"39": {
    "doc": "GitHub Actions",
    "title": "Example 1 - Run a container against the repository contents with every push",
    "content": "This example passes the branch name and several other secrets into a container, which clones the repository branch and performs a build against the code. Note it runs on pushes to main and staging, but also runs on a schedule at 8:00AM UTC each day.github/workflows/build.yaml . name: Build CI on: push: branches: - 'main' - 'staging' schedule: - cron: '0 8 * * *' jobs: Build: runs-on: ubuntu-latest steps: - uses: nelonoel/branch-name@v1 env: ACTIONS_ALLOW_UNSECURE_COMMANDS: true - run: echo ${BRANCH_NAME} - name: Set ENV vars env: BUCKET_NAME: $ BUCKET_NAME_STAGING: $ DISTRIBUTION_ID: $ STAGING_DISTRIBUTION_ID: $ MAX_AGE: $ AWS_ACCESS_KEY_ID: $ AWS_SECRET_ACCESS_KEY: $ run: echo $BUCKET_NAME - name: Get HUGO container run: docker pull ghcr.io/uvarc/hugo-build:v2 - name: Run HUGO container run: docker run -e BRANCH=$BRANCH_NAME -e DISTRIBUTION_ID=$ -e BUCKET_NAME_STAGING=$ -e STAGING_DISTRIBUTION_ID=$ -e AWS_ACCESS_KEY_ID=$ -e AWS_SECRET_ACCESS_KEY=$ -e MAX_AGE=$ ghcr.io/uvarc/hugo-build:v2 /root/build-site.sh uvarc/rc-website hugo-0.80.0-ext . ",
    "url": "/#example-1---run-a-container-against-the-repository-contents-with-every-push",
    
    "relUrl": "/#example-1---run-a-container-against-the-repository-contents-with-every-push"
  },"40": {
    "doc": "GitHub Actions",
    "title": "Example 2 - Build and push a container with all new tagged releases",
    "content": "This GitHub Action detects any tagged push (matching the format *.*, i.e. 1.4, 13.9, etc.) and performs a multi-architecture container build and push for both amd64 and arm64 platforms. Note at the end the Action performs a “Remote Dispatch” where it updates an external repository to set a new value, which in turn triggers a deployment.github/workflows/deploy.yaml . name: Container Build CICD on: push: tags: ['*.*'] env: REGISTRY: ghcr.io IMAGE_NAME: uvarc/id-generator SVC_NAME: idGenerator jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Set ENV run: echo \"IMAGE_TAG=${GITHUB_REF#refs/*/}\" &gt;&gt; $GITHUB_ENV - name: Set up QEMU uses: docker/setup-qemu-action@v3 - name: Set up Docker Buildx uses: docker/setup-buildx-action@v3 - name: Login to GHCR uses: docker/login-action@v3 with: registry: ghcr.io username: $ password: $ - name: Build and push uses: docker/build-push-action@v5 with: context: . platforms: linux/amd64,linux/arm64 tags: ghcr.io/$:$ labels: $ - name: Image digest run: echo $ # Update another repo so that Kubernetes deploys the new version. - name: Remote Dispatch run: | curl -X POST https://api.github.com/repos/uvarc/uvarc-services/dispatches \\ -H 'Accept: application/vnd.github.everest-preview+json' \\ -H \"Authorization: token $\" \\ --data '{\"event_type\": \"$ update to $\", \"client_payload\": { \"service\": \"$\", \"version\": \"$\" }}' . ",
    "url": "/#example-2---build-and-push-a-container-with-all-new-tagged-releases",
    
    "relUrl": "/#example-2---build-and-push-a-container-with-all-new-tagged-releases"
  },"41": {
    "doc": "Home",
    "title": "git and GitHub in Data Science",
    "content": "How to set up, configure, and work with git and GitHub. Get started now . ",
    "url": "/#git-and-github-in-data-science",
    
    "relUrl": "/#git-and-github-in-data-science"
  },"42": {
    "doc": "Home",
    "title": "What is git?",
    "content": "Git is a distributed version control system that tracks changes in any set of computer files, usually used for coordinating work among programmers who are collaboratively developing source code during software development. Its goals include speed, data integrity, and support for distributed, non-linear workflows. Wikipedia . ",
    "url": "/#what-is-git",
    
    "relUrl": "/#what-is-git"
  },"43": {
    "doc": "Home",
    "title": "What is GitHub?",
    "content": "GitHub is a developer platform that allows developers to create, store, manage and share their code. It uses Git software, providing the distributed version control of Git plus access control, bug tracking, software feature requests, task management, continuous integration, and wikis for every project. It currently hosts work by approximately 100M developers. Wikipedia . ",
    "url": "/#what-is-github",
    
    "relUrl": "/#what-is-github"
  },"44": {
    "doc": "Home",
    "title": "Git &amp; GitHub in Data Science",
    "content": "Data aggregation, cleaning, pipelines and ML models all rely on software in order to operate. Responsible software management depends on well-managed code, versioning, prioritizing bugs, features, and user issues. Further, modern platforms and infrastructure tend to favor code-driven tests, builds, deployment, and management. All of which is to say: Code is fundamental to our work, and it would be both risky and impractical to not use source control. ",
    "url": "/#git--github-in-data-science",
    
    "relUrl": "/#git--github-in-data-science"
  },"45": {
    "doc": "Home",
    "title": "Contents",
    "content": ". | Setup . | Install and set up git | Authenticate git to GitHub | Basic configuration | . | Creating and managing a repository . | Create a repository locally | Create a repository in GitHub | Adding or removing collaborators | . | Source control basics . | Diff | Status | Add | Commit | Push/Pull | Fetch | Log | . | Branches, Forks, and Merges . | Branches | Forks | Fetch from Upstream | Merges and Pull Requests | . | Issues | Advanced Git/GitHub Features . | Stash | Signing commits | Reset and Revert | Rebase | Cherry-pick | Renaming origin | Bonus | . | GitHub Actions . | About | Credentials &amp; Secrets | Example 1 - Build software upon a push | Example 2 - Build and deploy a container | . | . To use the theme, you do not need to clone or fork the [Just the Docs repo]! You should do that only if you intend to browse the theme docs locally, contribute to the development of the theme, or develop a new theme based on Just the Docs. This website documents the features of the current main branch of the Just the Docs theme. for a list of releases, new features, and bug fixes. ",
    "url": "/#contents",
    
    "relUrl": "/#contents"
  },"46": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  }
}
